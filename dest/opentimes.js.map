{
  "version": 3,
  "sources": ["../src/WeekDays.ts", "../src/OpenState.ts", "../src/helpers.ts", "../src/core/Normalizer.ts", "../src/converter/Microdata.ts", "../src/converter/Json.ts", "../src/converter/DisplayJson.ts", "../src/converter/DisplayText.ts", "../src/OpeningHours.ts"],
  "sourcesContent": ["export enum WeekDays {\n  Sunday = 0,\n  Monday = 1,\n  Tuesday = 2,\n  Wednesday = 3,\n  Thursday = 4,\n  Friday = 5,\n  Saturday = 6,\n}\n\nexport const WeekDaysShort = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"];\n", "export enum OpenState {\n  Closed,\n  Open,\n}\n", "import { OpenState } from \"./OpenState.ts\";\nimport { OpeningHoursOptions, OpenTimeInternal } from \"./interfaces.ts\";\n\nexport function toRemoteDate(date: Date, timeZone?: string) {\n  if (!timeZone) {\n    timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n  }\n\n  const offsetDate = new Date(\n    date.toLocaleString(\"sv\", { timeZone }).replace(\" \", \"T\"),\n  );\n\n  const offset = date.getTime() - offsetDate.getTime();\n  return new Date(date.getTime() + offset);\n}\n\nexport function fromRemoteDate(date: Date, timeZone?: string) {\n  if (!timeZone) {\n    timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n  }\n  const offsetDate = new Date(\n    date.toLocaleString(\"sv\", { timeZone }).replace(\" \", \"T\"),\n  );\n\n  const offset = date.getTime() - offsetDate.getTime();\n  return new Date(date.getTime() - offset);\n}\n\nexport function normalizeUntilTime(date: Date) {\n  if (date.getHours() === 0 && date.getMinutes() === 0) {\n    date.setHours(23);\n    date.setMinutes(59);\n  }\n}\n\nexport function sortTimespan(times: OpenTimeInternal[]) {\n  times.sort((a, b) =>\n    a.from < b.from || a.until < b.from ? -1 : a.from > b.until ? 1 : 0\n  );\n}\n\nexport function mergeTimespans(times: OpenTimeInternal[]) {\n  const tmp = times.splice(0);\n  let last!: OpenTimeInternal;\n  for (const time of tmp) {\n    if (!last || time.from > last.until) {\n      times.push(time);\n      last = time;\n    } else if (time.until > last.until) {\n      last.until = time.until;\n    }\n  }\n}\n\nexport function cutTimespans(\n  openTimes: OpenTimeInternal[][],\n  removableTimes: OpenTimeInternal[][],\n) {\n  for (const [day, removables] of removableTimes.entries()) {\n    if (0 === removables.length) {\n      continue;\n    }\n    for (const removable of removables) {\n      const times = openTimes[day];\n      const tmp = times.splice(0);\n      for (const time of tmp) {\n        // no remove operation needed\n        if (time.from > removable.until || time.until < removable.from) {\n          times.push(time);\n        } // cut in two time objects\n        else if (time.from < removable.from && time.until > removable.until) {\n          times.push(\n            {\n              from: time.from,\n              until: removable.from,\n            },\n            {\n              from: removable.until,\n              until: time.until,\n            },\n          );\n        } // cut start time (from)\n        else if (\n          time.from >= removable.from &&\n          time.from <= removable.until &&\n          time.until > removable.until\n        ) {\n          times.push({\n            from: removable.until,\n            until: time.until,\n          });\n        } // cut end time (until)\n        else if (\n          time.until <= removable.until &&\n          time.until >= removable.from &&\n          time.from < removable.from\n        ) {\n          times.push({\n            from: time.from,\n            until: removable.from,\n          });\n        }\n      }\n    }\n  }\n}\n\nexport function postOptimize(openTimes: OpenTimeInternal[][]) {\n  for (const times of openTimes.values()) {\n    sortTimespan(times);\n    mergeTimespans(times);\n  }\n}\n\nexport function getState(\n  openTimes: OpenTimeInternal[][],\n  options: OpeningHoursOptions,\n  now = new Date(),\n) {\n  // make sure the timeZone is set with a value.\n  // At least the local time of the current client.\n  const { timeZone } = Intl.DateTimeFormat(\n    options.locales,\n    options.dateTimeFormatOptions,\n  ).resolvedOptions();\n  const current = fromRemoteDate(now, timeZone);\n  const day = current.getDay();\n  for (const time of openTimes[day]) {\n    const from = time.from;\n    const until = time.until;\n    if (from <= current && until >= current) {\n      return OpenState.Open;\n    }\n  }\n  return OpenState.Closed;\n}\n\nexport function createDateTime(date: Date, day: number, timeStr: string) {\n  const dateStr = date.toISOString().slice(0, 10);\n  const datetime = new Date(dateStr + \"T\" + timeStr);\n  const offset = day - datetime.getDay();\n  datetime.setDate(datetime.getDate() + (day < 7 ? offset : 0));\n  return datetime;\n}\n\n/**\n * creates an entry in the correct day array\n */\nexport function insertOpenTime(\n  input: OpenTimeInternal[],\n  output: OpenTimeInternal[][],\n) {\n  for (const time of input) {\n    const times = output[time.from.getDay()];\n    times.push({ ...time });\n  }\n}\n", "import { WeekDays } from \"../WeekDays.ts\";\nimport { normalizeUntilTime, createDateTime, fromRemoteDate } from \"../helpers.ts\";\nimport {\n  OpeningHoursOptions,\n  OpenTimeInput,\n  OpenTimeInternal,\n} from \"../interfaces.ts\";\n\nexport class Normalizer {\n  constructor(private options: OpeningHoursOptions) {}\n\n  normalize(time: OpenTimeInput, removePattern?: RegExp): OpenTimeInternal[] {\n    const internal: OpenTimeInternal = {\n      from: this.normalizeTimeString(time.from, time.day, removePattern),\n      until: this.normalizeTimeString(time.until, time.day, removePattern),\n    };\n    normalizeUntilTime(internal.until);\n\n    const result = [];\n    if (internal.until < internal.from) {\n      const untilPrevDay = createDateTime(\n        this.options.currentDate,\n        internal.from.getDay(),\n        \"23:59:00\"\n      );\n\n      const nextDayFrom = createDateTime(\n        this.options.currentDate,\n        internal.until.getDay() + 1,\n        \"00:00:00\"\n      );\n\n      const nextDayUntil = createDateTime(\n        this.options.currentDate,\n        internal.until.getDay() + 1,\n        internal.until.toLocaleTimeString(\"sv\")\n      );\n\n      internal.until.setDate(internal.until.getDate() + 1);\n      result.push(\n        {\n          from: internal.from,\n          until: untilPrevDay,\n        },\n        {\n          from: nextDayFrom,\n          until: nextDayUntil,\n        }\n      );\n    } else {\n      result.push(internal);\n    }\n\n    return result;\n  }\n\n  /**\n   * Creates a date object from currentDate and the given\n   * opening hours time.\n   */\n  private getTimeByCurrentDay(date: Date | [number, number, number, number]) {\n    if (Array.isArray(date)) {\n      const currentDate = this.options.currentDate;\n      const timeZone = this.options.dateTimeFormatOptions.timeZone;\n      const [day, hours, minutes, seconds] = date;\n\n      const current = fromRemoteDate(currentDate, timeZone);\n      const dayOffset = day - current.getDay();\n      current.setDate(current.getDate() + dayOffset);\n      current.setHours(hours);\n      current.setMinutes(minutes);\n      current.setSeconds(seconds);\n\n      return current;\n    } else {\n      return date;\n    }\n  }\n\n  /**\n   * this method is the magical unicorn that gets all the funky shit done!\n   * - Interpreting Date, Unix Timestamp, ISO 8601 DateTime => CHECK\n   * - Interpreting fuzzy 24h time strings => CHECK\n   */\n  private normalizeTimeString(\n    time: Date | number | string,\n    day: WeekDays,\n    pattern = /\\d{1,2}/g\n  ) {\n    const date = new Date(time);\n    if (\n      time instanceof Date ||\n      (\"Invalid Date\" !== date.toString() &&\n        \"string\" === typeof time &&\n        time.length >= 16)\n    ) {\n      return this.getTimeByCurrentDay(date);\n    } else if (\"string\" === typeof time) {\n      const matched = time.match(pattern);\n      if (matched) {\n        let [hours, minutes, seconds] = matched\n          .slice(0, 3)\n          .map((n) => parseInt(n));\n\n        // make sure second has a valid value.\n        if (\"undefined\" === typeof seconds) {\n          seconds = 0;\n        }\n\n        // I'm zeroing the values 24:00 and 23:59,\n        // because I need a solid foundation to\n        // normalize for after midnight\n\n        if (hours === 24 && minutes === 0) {\n          hours = 0;\n        }\n        if (hours === 23 && minutes === 59) {\n          hours = 0;\n          minutes = 0;\n        }\n        const date = this.getTimeByCurrentDay([day, hours, minutes, seconds]);\n        if (date.getDay() !== day) {\n          date.setDate(date.getDate() - 1);\n        }\n        return date;\n      }\n    }\n    throw new Error(`Invalid time string: ${time}`);\n  }\n}\n", "import { OpeningHoursOptions, OpenTimeInternal } from \"../interfaces.ts\";\nimport { createDateTime, insertOpenTime, postOptimize } from \"../helpers.ts\";\nimport { Exporter, Importer } from \"../Converter.ts\";\nimport { Normalizer } from \"../core/Normalizer.ts\";\n\nconst mapping = [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"];\n\nexport declare type MicrodataFormat = string | string[];\n\nexport class Microdata\n  implements\n    Importer<MicrodataFormat, OpeningHoursOptions>,\n    Exporter<MicrodataFormat, OpeningHoursOptions>\n{\n  toData(input: OpenTimeInternal[][], options: OpeningHoursOptions) {\n    const format: Intl.DateTimeFormatOptions = {\n      ...options.dateTimeFormatOptions,\n    };\n    delete format.timeZone;\n\n    const tmp: { [span: string]: number[] } = {};\n\n    for (const [day, spans] of input.entries()) {\n      for (const { from, until } of spans) {\n        const span =\n          from.toLocaleTimeString(\"sv\", format) +\n          \"-\" +\n          until.toLocaleTimeString(\"sv\", format);\n        if (!tmp[span]) {\n          tmp[span] = [day];\n        } else if (!tmp[span].includes(day)) {\n          tmp[span].push(day);\n        }\n      }\n    }\n\n    const result = [];\n    for (const [span, days] of Object.entries(tmp)) {\n      days.sort();\n\n      let prev = -1;\n      let tmp = null;\n      const weekDays = days\n        .reduce<number[][]>((result, day) => {\n          if (-1 === prev || day !== prev + 1) {\n            tmp = [day];\n            result.push(tmp);\n          } else {\n            tmp.push(day);\n          }\n          prev = day;\n          return result;\n        }, [])\n        .map((days) =>\n          days.length > 1\n            ? `${mapping[days[0]]}-${mapping[days[days.length - 1]]}`\n            : mapping[days[0]]\n        )\n        .join(\",\");\n\n      result.push(`${weekDays} ${span}`);\n    }\n\n    return result.length > 1 ? result : result[0] || \"\";\n  }\n\n  fromData(\n    input: MicrodataFormat,\n    options: OpeningHoursOptions\n  ): OpenTimeInternal[][] {\n    const times: OpenTimeInternal[][] = [[], [], [], [], [], [], []];\n    const currentDate = options.currentDate || new Date();\n    const rows = \"string\" === typeof input ? [input] : input;\n    const daysRE = /[a-z]{2}-[a-z]{2}|[a-z]{2}/gi;\n    const timeRE = /\\d{2}:\\d{2}:\\d{2}|\\d{2}:\\d{2}/g;\n    const normalizer = new Normalizer(options);\n    for (const row of rows) {\n      const dayspan = row.match(daysRE) || [];\n      const [fromStr, untilStr] = row.match(timeRE) || [\"00:00\", \"23:59\"];\n      for (const span of dayspan) {\n        const [startDayStr, endDayStr] = span.split(\"-\");\n        const startDay = mapping.indexOf(startDayStr);\n        const endDay = mapping.indexOf(endDayStr);\n        for (let i = 0; i < 7; i++) {\n          if (\n            (startDay === i && endDay === -1) ||\n            (endDay > -1 &&\n              ((endDay < startDay && (i <= endDay || i >= startDay)) ||\n                (i >= startDay && i <= endDay)))\n          ) {\n            const chunk = normalizer.normalize({\n              day: i,\n              from: createDateTime(currentDate, i, fromStr),\n              until: createDateTime(currentDate, i, untilStr),\n            });\n            insertOpenTime(chunk, times);\n          }\n        }\n      }\n    }\n    postOptimize(times);\n    return times;\n  }\n}\n", "import {\n  OpenTimeInput,\n  OpenTimeOutput,\n  OpeningHoursOptions,\n  OpenTimeInternal,\n} from \"../interfaces.ts\";\nimport { Exporter, Importer } from \"../Converter.ts\";\nimport { Normalizer } from \"../core/Normalizer.ts\";\nimport { insertOpenTime, postOptimize } from \"../helpers.ts\";\n\nexport class Json\n  implements\n    Importer<OpenTimeInput[], OpeningHoursOptions>,\n    Exporter<OpenTimeOutput[], OpeningHoursOptions>\n{\n  toData(\n    input: OpenTimeInternal[][],\n    options: OpeningHoursOptions\n  ): OpenTimeOutput[] {\n    const result: OpenTimeOutput[] = [];\n    const format: Intl.DateTimeFormatOptions = {\n      ...options.dateTimeFormatOptions,\n    };\n    delete format.timeZone;\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i].length === 0) {\n        continue;\n      }\n      for (const { from, until, text } of input[i]) {\n        result.push({\n          day: i,\n          from: from.toLocaleTimeString(\"sv\", format).replace(/:/g, \"\"),\n          until: until.toLocaleTimeString(\"sv\", format).replace(/:/g, \"\"),\n          text,\n        });\n      }\n    }\n\n    return result;\n  }\n\n  fromData(input: OpenTimeInput[], options: OpeningHoursOptions) {\n    const times: OpenTimeInternal[][] = [[], [], [], [], [], [], []];\n    const normalizer = new Normalizer(options);\n\n    for (const data of input) {\n      const chunk = normalizer.normalize(data);\n      insertOpenTime(chunk, times);\n    }\n    postOptimize(times);\n    return times;\n  }\n}\n", "import { fromRemoteDate } from \"../helpers.ts\";\nimport { Exporter } from \"../Converter.ts\";\nimport {\n  OpenTimeResultOutput,\n  OpeningHoursOptions,\n  OpenTimeInternal,\n} from \"../interfaces.ts\";\nimport { WeekDaysShort } from \"../WeekDays.ts\";\n\nexport class DisplayJson\n  implements Exporter<OpenTimeResultOutput[], OpeningHoursOptions>\n{\n  toData(input: OpenTimeInternal[][], options: OpeningHoursOptions) {\n    const format: Intl.DateTimeFormatOptions = {\n      ...options.dateTimeFormatOptions,\n    };\n    const timeZone = options.dateTimeFormatOptions.timeZone;\n    delete format.timeZone;\n\n    const { currentDate, locales } = options;\n    const weekDays = options.text?.weekDays || WeekDaysShort;\n    const openTimes = [];\n    for (const [day, times] of input.entries()) {\n      const active = fromRemoteDate(currentDate, timeZone).getDay() === day;\n      if (times.length === 0) {\n        // create an object if showClosedDays is enabled.\n        openTimes[day] = options.showClosedDays\n          ? {\n              active,\n              day: weekDays[day],\n              times: [],\n            }\n          : null;\n      } else {\n        // insert opening hours with the correct time format and\n        // add the translation of the current day.\n        openTimes[day] = {\n          active,\n          day: weekDays[day],\n          times: times.map((time) => {\n            const fromDate = time.from;\n            const untilDate = time.until;\n\n            if (untilDate.getHours() === 0 && untilDate.getMinutes() === 0) {\n              untilDate.setHours(23);\n              untilDate.setMinutes(59);\n              untilDate.setSeconds(0);\n              untilDate.setMilliseconds(0);\n            }\n\n            const from = fromDate.toLocaleTimeString(locales, format);\n            const until = untilDate.toLocaleTimeString(locales, format);\n\n            return { from, until };\n          }),\n        };\n      }\n    }\n\n    // reorder openTimes array to set the currently\n    // leading week day at the top.\n    this.setLeadingDay(openTimes, options);\n    const result = [];\n\n    // discard empty days\n    for (const item of openTimes) {\n      if (item) {\n        result.push(item);\n      }\n    }\n    return result as OpenTimeResultOutput[];\n  }\n\n  /**\n   * defines the leading week day by\n   * currentDayOnTop and weekStart options.\n   */\n  private setLeadingDay<T>(result: T[], options: Partial<OpeningHoursOptions>) {\n    const { currentDate, currentDayOnTop, weekStart } = options;\n    const timeZone = options.dateTimeFormatOptions?.timeZone;\n    const weekDay =\n      currentDate && currentDayOnTop\n        ? fromRemoteDate(currentDate, timeZone).getDay()\n        : weekStart !== undefined\n        ? weekStart\n        : 0;\n    if (weekDay > 0) {\n      const previous = result.splice(weekDay);\n      result.unshift(...previous);\n    }\n  }\n}\n", "import { OpeningHoursOptions, OpenTimeInternal } from \"../interfaces.ts\";\nimport { Exporter } from \"../Converter.ts\";\nimport { DisplayJson } from \"./DisplayJson.ts\";\n\nexport class DisplayText\n  implements Exporter<string, OpeningHoursOptions>\n{\n  toData(input: OpenTimeInternal[][], options: OpeningHoursOptions) {\n    const { timespanSeparator, closed } = options.text || {};\n    const result = [];\n    const jsonConverter = new DisplayJson();\n    const openTimes = jsonConverter.toData(input, options);\n    for (const obj of openTimes) {\n      let resultStr: string;\n      if (obj.times.length) {\n        resultStr = `${obj.day} ${obj.times\n          .map((time) => time.from + timespanSeparator + time.until)\n          .join(\", \")}`;\n      } else {\n        resultStr = `${obj.day} ${closed}`;\n      }\n      result.push(obj.active ? \"[\" + resultStr + \"]\" : resultStr);\n    }\n    return result.join(\"\\n\");\n  }\n}\n", "import { Microdata, MicrodataFormat } from \"./converter/Microdata.ts\";\nimport { Json } from \"./converter/Json.ts\";\nimport { DisplayJson } from \"./converter/DisplayJson.ts\";\nimport { DisplayText } from \"./converter/DisplayText.ts\";\nimport {\n  cutTimespans,\n  fromRemoteDate,\n  getState,\n  insertOpenTime,\n  postOptimize,\n} from \"./helpers.ts\";\nimport {\n  DateType,\n  OpeningHoursOptions,\n  OpenTimeInput,\n  OpenTimeInternal,\n  OpenTimeRemovableInput,\n  OpenTimeResultOutput,\n} from \"./interfaces.ts\";\nimport { WeekDays, WeekDaysShort } from \"./WeekDays.ts\";\nimport { Normalizer } from \"./core/Normalizer.ts\";\nimport { OpenState } from \"./OpenState.ts\";\n\nexport class OpeningHours {\n  static readonly defaultOptions: OpeningHoursOptions = {\n    weekStart: WeekDays.Monday,\n    currentDate: new Date(),\n    currentDayOnTop: false,\n    locales: \"de-DE\",\n    dateTimeFormatOptions: {\n      timeZone: \"Europe/Berlin\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    },\n    text: {\n      closed: \"closed\",\n      open: \"open\",\n      timespanSeparator: \" - \",\n      weekDays: WeekDaysShort,\n    },\n    showClosedDays: false,\n  };\n\n  readonly options!: OpeningHoursOptions;\n\n  currentDate!: Date;\n\n  // TODO: add some info text to seasonal opening/closing times\n  get times(): OpenTimeInternal[][] {\n    const currentDate = this.currentDate;\n    const weekDay = currentDate.getDay();\n    const result = this.internalTimes.default.slice(0);\n    const emptyTimes = [[], [], [], [], [], [], []];\n    for (const season of this.internalTimes.seasons.values()) {\n      for (let i = 0; i < 7; i++) {\n        if (weekDay > i) {\n          currentDate.setDate(currentDate.getDate() - (weekDay - i));\n        } else {\n          currentDate.setDate(currentDate.getDate() + i);\n        }\n        if (currentDate >= season.fromDate && currentDate <= season.untilDate) {\n          result[i] = (season.times || emptyTimes)[i].slice(0);\n        }\n      }\n    }\n    return result;\n  }\n\n  private internalTimes: {\n    default: OpenTimeInternal[][];\n    seasons: Set<{\n      fromDate: Date;\n      untilDate: Date;\n      text?: string;\n      times?: OpenTimeInternal[][];\n    }>;\n  };\n\n  constructor(options: Partial<OpeningHoursOptions> = {}) {\n    // prepare options\n    this.options = {\n      ...OpeningHours.defaultOptions,\n      ...options,\n      dateTimeFormatOptions: {\n        ...OpeningHours.defaultOptions.dateTimeFormatOptions,\n        ...(options.dateTimeFormatOptions || {}),\n      },\n      text: {\n        ...OpeningHours.defaultOptions.text,\n        ...(options.text || {}),\n      },\n    };\n\n    this.currentDate = this.options.currentDate;\n\n    // setup a 2D array for 7 days, started by sunday.\n    this.internalTimes = {\n      default: [[], [], [], [], [], [], []],\n      seasons: new Set(),\n    };\n  }\n\n  getState(now = new Date()): OpenState {\n    return getState(this.internalTimes.default, this.options, now);\n  }\n\n  /**\n   * Check if the subject is opening soon. Default is 30 minutes or\n   * 1800 seconds.\n   */\n  isOpenSoon(now = new Date(), elapseSeconds?: number) {\n    // make sure the timeZone is set with a value.\n    // At least the local time of the current client.\n    const { timeZone } = Intl.DateTimeFormat(\n      this.options.locales,\n      this.options.dateTimeFormatOptions,\n    ).resolvedOptions();\n    const current = fromRemoteDate(now, timeZone);\n    const day = current.getDay();\n    const soon = new Date(current);\n    soon.setSeconds(soon.getSeconds() + (elapseSeconds || 1800));\n    for (const time of this.times[day]) {\n      const from = time.from;\n      if (from >= current && from <= soon) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the subject is closing soon. Default is 30 minutes or\n   * 1800 seconds.\n   */\n  isClosedSoon(now = new Date(), elapseSeconds?: number) {\n    // make sure the timeZone is set with a value.\n    // At least the local time of the current client.\n    const { timeZone } = Intl.DateTimeFormat(\n      this.options.locales,\n      this.options.dateTimeFormatOptions,\n    ).resolvedOptions();\n    const current = fromRemoteDate(now, timeZone);\n    const day = current.getDay();\n    const soon = new Date(current);\n    soon.setSeconds(soon.getSeconds() + (elapseSeconds || 1800));\n    for (const time of this.times[day]) {\n      const from = time.from;\n      const until = time.until;\n      if (from <= current && until >= current && soon > until) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the local time string of the next opening time.\n   */\n  getNextOpenTime(now = new Date()) {\n    // make sure the timeZone is set with a value.\n    // At least the local time of the current client.\n    const { timeZone } = Intl.DateTimeFormat(\n      this.options.locales,\n      this.options.dateTimeFormatOptions,\n    ).resolvedOptions();\n    const { locales } = this.options;\n    const format: Intl.DateTimeFormatOptions = {\n      ...this.options.dateTimeFormatOptions,\n    };\n    delete format.timeZone;\n    const current = fromRemoteDate(now, timeZone);\n    const day = current.getDay();\n    for (const time of this.times[day]) {\n      const from = time.from;\n      const until = time.until;\n      if (from <= current && until >= current) {\n        return this.options.text.open;\n      }\n      if (from > current && until > current) {\n        return from.toLocaleTimeString(locales, format);\n      }\n    }\n    return this.options.text.closed;\n  }\n\n  /**\n   * add a single time object and optimize it\n   */\n  add(day: WeekDays, from: DateType, until: DateType) {\n    const normalizer = new Normalizer(this.options);\n    const time = { day, from, until };\n    const optimized = normalizer.normalize(time);\n    insertOpenTime(optimized, this.internalTimes.default);\n    postOptimize(this.internalTimes.default);\n  }\n\n  /**\n   * Cut a timespan out of the opening hours.\n   */\n  cut(days: WeekDays | WeekDays[], from: DateType, until: DateType) {\n    if (\"number\" === typeof days) {\n      days = [days];\n    }\n    const normalizer = new Normalizer(this.options);\n    const removables: OpenTimeInternal[][] = [[], [], [], [], [], [], []];\n    for (const day of days) {\n      const time = { day, from, until };\n\n      const optimized = normalizer.normalize(time);\n      insertOpenTime(optimized, removables);\n    }\n    cutTimespans(this.internalTimes.default, removables);\n    postOptimize(this.internalTimes.default);\n  }\n\n  /**\n   * Cut multiple chunks out of the opening hours.\n   */\n  cutMulti(input: Array<OpenTimeRemovableInput>) {\n    const normalizer = new Normalizer(this.options);\n    const removables: OpenTimeInternal[][] = [[], [], [], [], [], [], []];\n    for (const removable of input) {\n      const days = [];\n      const times = [];\n      if (\"undefined\" !== typeof removable.days) {\n        days.push(...removable.days);\n      } else if (\"number\" === typeof removable.day) {\n        days.push(removable.day);\n      }\n\n      if (\"undefined\" !== typeof removable.spans) {\n        for (const span of removable.spans) {\n          for (const day of days) {\n            times.push({\n              day,\n              from: span.from || \"0000\",\n              until: span.until || \"2359\",\n            });\n          }\n        }\n      } else {\n        for (const day of days) {\n          times.push({\n            day,\n            from: removable.from || \"0000\",\n            until: removable.until || \"2359\",\n          });\n        }\n      }\n\n      for (const time of times) {\n        const optimized = normalizer.normalize(time);\n        insertOpenTime(optimized, removables);\n      }\n    }\n\n    cutTimespans(this.internalTimes.default, removables);\n    postOptimize(this.internalTimes.default);\n  }\n\n  fromJSON(times: OpenTimeInput[], options: Partial<OpeningHoursOptions> = {}) {\n    const converter = new Json();\n    this.internalTimes.default.splice(0);\n\n    const internalTimes = converter.fromData(times, {\n      ...this.options,\n      ...options,\n    });\n\n    this.internalTimes.default.push(...internalTimes);\n  }\n\n  /**\n   * Creates normalized JSON format.\n   */\n  toJSON(options?: Partial<OpeningHoursOptions>): OpenTimeInput[] {\n    const converter = new Json();\n    return converter.toData(this.times, {\n      ...this.options,\n      ...(options || {}),\n    });\n  }\n\n  fromMicrodata(\n    times: MicrodataFormat,\n    options: Partial<OpeningHoursOptions> = {},\n  ) {\n    const converter = new Microdata();\n    this.internalTimes.default.splice(0);\n\n    const internalTimes = converter.fromData(times, {\n      ...this.options,\n      ...options,\n    });\n\n    this.internalTimes.default.push(...internalTimes);\n  }\n\n  /**\n   * Creates a string or a string array output of opening hours\n   * in microdata format.\n   */\n  toMicrodata(options?: Partial<OpeningHoursOptions>) {\n    const converter = new Microdata();\n    return converter.toData(this.times, {\n      ...this.options,\n      ...(options || {}),\n    });\n  }\n\n  /**\n   * Creates an array output for opening hours.\n   */\n  toLocaleJSON(options?: Partial<OpeningHoursOptions>): OpenTimeResultOutput[] {\n    const converter = new DisplayJson();\n    return converter.toData(this.times, {\n      ...this.options,\n      ...(options || {}),\n    });\n  }\n\n  /**\n   * Creates a string output for opening hours.\n   */\n  toString(options?: Partial<OpeningHoursOptions>) {\n    const converter = new DisplayText();\n    return converter.toData(this.times, {\n      ...this.options,\n      ...(options || {}),\n    });\n  }\n}\n\nexport default function createOpeningHours(options?: OpeningHoursOptions) {\n  return new OpeningHours(options);\n}\n"],
  "mappings": "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",
  "names": ["WeekDays", "WeekDaysShort", "OpenState", "fromRemoteDate", "date", "timeZone", "offsetDate", "offset", "normalizeUntilTime", "sortTimespan", "times", "a", "b", "mergeTimespans", "tmp", "last", "time", "cutTimespans", "openTimes", "removableTimes", "day", "removables", "removable", "postOptimize", "getState", "options", "now", "current", "from", "until", "createDateTime", "timeStr", "dateStr", "datetime", "insertOpenTime", "input", "output", "Normalizer", "options", "time", "removePattern", "internal", "normalizeUntilTime", "result", "untilPrevDay", "createDateTime", "nextDayFrom", "nextDayUntil", "date", "currentDate", "timeZone", "day", "hours", "minutes", "seconds", "current", "fromRemoteDate", "dayOffset", "pattern", "matched", "n", "mapping", "Microdata", "input", "options", "format", "tmp", "day", "spans", "from", "until", "span", "result", "days", "prev", "weekDays", "times", "currentDate", "rows", "daysRE", "timeRE", "normalizer", "Normalizer", "row", "dayspan", "fromStr", "untilStr", "startDayStr", "endDayStr", "startDay", "endDay", "i", "chunk", "createDateTime", "insertOpenTime", "postOptimize", "Json", "input", "options", "result", "format", "from", "until", "text", "times", "normalizer", "Normalizer", "data", "chunk", "insertOpenTime", "postOptimize", "DisplayJson", "input", "options", "format", "timeZone", "currentDate", "locales", "weekDays", "WeekDaysShort", "openTimes", "day", "times", "active", "fromRemoteDate", "time", "fromDate", "untilDate", "from", "until", "result", "item", "currentDayOnTop", "weekStart", "weekDay", "previous", "DisplayText", "input", "options", "timespanSeparator", "closed", "result", "openTimes", "DisplayJson", "obj", "resultStr", "time", "OpeningHours", "_OpeningHours", "WeekDaysShort", "currentDate", "weekDay", "result", "emptyTimes", "season", "i", "options", "now", "getState", "elapseSeconds", "timeZone", "current", "fromRemoteDate", "day", "soon", "time", "from", "until", "locales", "format", "normalizer", "Normalizer", "optimized", "insertOpenTime", "postOptimize", "days", "removables", "cutTimespans", "input", "removable", "times", "span", "converter", "Json", "internalTimes", "Microdata", "DisplayJson", "DisplayText"]
}
